// MIT License
// Copyright (c) 2026 Christian Luppi

#pragma once

// Required for compiler detection and platform-specific definitions.
#include "env_defines.h"

// Include standard boolean type for 'bool', 'true', and 'false'.
#include <stdbool.h>

/*
Define custom keywords used in the project.
I like custom keywords, they make the code more readable to me, you can 100% tell
what they do even if they are not standard C keywords.
Some compilers/platforms have different names for the same thing,
so I want to have a single place where I can define them and use them throughout the project.

Functional keywords:
- 'thread_local' for thread-local storage.
- 'dll_export' for exporting symbols from a shared library.
- 'dll_import' for importing symbols from a shared library.
- 'static_assert' for compile-time assertions.
- 'no_return' for functions that do not return to the caller.
- 'force_inline' for suggesting the compiler to inline a function.
- 'no_inline' for suggesting the compiler not to inline a function.
- 'align_as' for specifying the alignment of a variable or type.
- 'align_of' for querying the alignment requirement of a type.
- 'likely' and 'unlikely' for branch prediction hints to the compiler.
- 'read_only' for variables that are constant and should not be modified after init.

Purely cosmetic keywords:
- 'func' as a shorthand for 'function' to improve readability.
- 'global_var' for global variables to make it clear they are global.
- 'local_persist' for static variables that should persist across function calls.

If ALL_FUNCS_STATIC is defined, all functions will be declared as static.
If ALL_GLOBAL_VARS_STATIC is defined, all global variables will be declared as static.
*/

// =========================================================================
// Functional Keywords
// =========================================================================

// thread_local — thread-local storage duration.
#if defined(__cplusplus) && __cplusplus >= 201103L
// C++11 keyword — already defined.
#elif defined(__STDC_VERSION__) && __STDC_VERSION__ >= 201112L
#  define thread_local _Thread_local
#elif defined(COMPILER_MSVC)
#  define thread_local __declspec(thread)
#elif defined(COMPILER_GCC) || defined(COMPILER_CLANG) || \
    defined(COMPILER_APPLE_CLANG) || defined(COMPILER_INTEL)
#  define thread_local __thread
#else
#  define thread_local
#endif

// dll_export / dll_import — symbol visibility for shared libraries.
#if defined(PLATFORM_WINDOWS)
#  define dll_export __declspec(dllexport)
#  define dll_import __declspec(dllimport)
#elif defined(COMPILER_GCC) || defined(COMPILER_CLANG) || \
    defined(COMPILER_APPLE_CLANG) || defined(COMPILER_INTEL)
#  define dll_export __attribute__((visibility("default")))
#  define dll_import
#else
#  define dll_export
#  define dll_import
#endif

// static_assert — compile-time assertion.
// Guard against redefining a language keyword or existing macro.
#ifndef static_assert
#  if defined(__cplusplus) && __cplusplus >= 201103L
// C++11 keyword — already defined.
#  elif defined(__STDC_VERSION__) && __STDC_VERSION__ >= 201112L
#    define static_assert _Static_assert
#  else
#    define static_assert(expr, msg) typedef char static_assert_##__COUNTER__[(expr) ? 1 : -1]
#  endif
#endif

// no_return — function does not return to the caller.
#if defined(__cplusplus) && __cplusplus >= 201103L
#  define no_return [[noreturn]]
#elif defined(__STDC_VERSION__) && __STDC_VERSION__ >= 201112L
#  define no_return _Noreturn
#elif defined(COMPILER_MSVC)
#  define no_return __declspec(noreturn)
#elif defined(COMPILER_GCC) || defined(COMPILER_CLANG) || \
    defined(COMPILER_APPLE_CLANG) || defined(COMPILER_INTEL)
#  define no_return __attribute__((noreturn))
#else
#  define no_return
#endif

// force_inline — ask the compiler to always inline this function.
#if defined(COMPILER_MSVC) || defined(COMPILER_INTEL)
#  define force_inline __forceinline
#elif defined(COMPILER_GCC) || defined(COMPILER_CLANG) || \
    defined(COMPILER_APPLE_CLANG)
#  define force_inline __attribute__((always_inline)) inline
#else
#  define force_inline inline
#endif

// no_inline — ask the compiler never to inline this function.
#if defined(COMPILER_MSVC) || defined(COMPILER_INTEL)
#  define no_inline __declspec(noinline)
#elif defined(COMPILER_GCC) || defined(COMPILER_CLANG) || \
    defined(COMPILER_APPLE_CLANG)
#  define no_inline __attribute__((noinline))
#else
#  define no_inline
#endif

// align_as — specify the alignment of a variable or type.
#if defined(__cplusplus) && __cplusplus >= 201103L
#  define align_as(x) alignas(x)
#elif defined(__STDC_VERSION__) && __STDC_VERSION__ >= 201112L
#  define align_as(x) _Alignas(x)
#elif defined(COMPILER_MSVC)
#  define align_as(x) __declspec(align(x))
#elif defined(COMPILER_GCC) || defined(COMPILER_CLANG) || \
    defined(COMPILER_APPLE_CLANG) || defined(COMPILER_INTEL)
#  define align_as(x) __attribute__((aligned(x)))
#else
#  define align_as(x)
#endif

// align_of — query the alignment requirement of a type.
#if defined(__cplusplus) && __cplusplus >= 201103L
#  define align_of(x) alignof(x)
#elif defined(__STDC_VERSION__) && __STDC_VERSION__ >= 201112L
#  define align_of(x) _Alignof(x)
#elif defined(COMPILER_MSVC)
#  define align_of(x) __alignof(x)
#elif defined(COMPILER_GCC) || defined(COMPILER_CLANG) || \
    defined(COMPILER_APPLE_CLANG) || defined(COMPILER_INTEL)
#  define align_of(x) __alignof__(x)
#else
#  define align_of(x) sizeof(x)
#endif

// likely / unlikely — branch prediction hints.
#if defined(COMPILER_GCC) || defined(COMPILER_CLANG) || \
    defined(COMPILER_APPLE_CLANG) || defined(COMPILER_INTEL)
#  define likely(x)   __builtin_expect(!!(x), 1)
#  define unlikely(x) __builtin_expect(!!(x), 0)
#else
#  define likely(x)   (x)
#  define unlikely(x) (x)
#endif

// read_only — constant variable explicitly placed in the read-only data section.
// MSVC  → .rdata   (PE read-only data segment)
// Linux → .rodata  (ELF read-only data segment)
// macOS → __TEXT,__const (Mach-O read-only text segment)
// Note: must have a compile-time constant initializer; use at global/file scope only.
#if defined(COMPILER_MSVC)
#  pragma section(".rdata", read)
#  if defined(ALL_GLOBAL_VARS_STATIC)
#    define read_only static __declspec(allocate(".rdata")) const
#  else
#    define read_only __declspec(allocate(".rdata")) const
#  endif
#elif defined(COMPILER_APPLE_CLANG)
#  if defined(ALL_GLOBAL_VARS_STATIC)
#    define read_only static const __attribute__((section("__TEXT,__const")))
#  else
#    define read_only const __attribute__((section("__TEXT,__const")))
#  endif
#elif defined(COMPILER_GCC) || defined(COMPILER_CLANG) || defined(COMPILER_INTEL)
#  if defined(ALL_GLOBAL_VARS_STATIC)
#    define read_only static const __attribute__((section(".rodata")))
#  else
#    define read_only const __attribute__((section(".rodata")))
#  endif
#else
#  if defined(ALL_GLOBAL_VARS_STATIC)
#    define read_only static const
#  else
#    define read_only const
#  endif
#endif

// =========================================================================
// Cosmetic Keywords
// =========================================================================

// local_persist — static variable that retains its value across calls.
#define local_persist static

// global_var — global variable (purely cosmetic, improves readability).
#if defined(ALL_GLOBAL_VARS_STATIC)
#  define global_var static
#else
#  define global_var
#endif

// func — function declaration; static if ALL_FUNCS_STATIC is defined.
#if defined(ALL_FUNCS_STATIC)
#  define func static
#else
#  define func
#endif